AERO		- TRIVIAL 					- imprimir os índices de um vetor correspondentes às posições que armazenam o maior inteiro desse vetor. (http://spojtricks.blogspot.com.br/2014/07/818-aeroporto.html)
ACOES1MG	- RECURSÃO, CONTAGEM		- Contar de maneira recursiva a quantidade de parte que o dinheiro será dividido. (http://spojtricks.blogspot.com.br/2014/06/11753-investindo-no-mercado-de-acoes-1.html)
ALADES		- TRIVIAL 					- calcular a diferença em minutos de dois horários dados no formato hh:mm. No caso em que os dois horários são iguais, deve-se imprimir 1440.
ANONOVO		- TRIVIAL					- calcular o tempo em segundos faltante para se atingir meia noite. (http://br.spoj.com/problems/ANONOVO/)
ALTAS2		- DP						- dados K balões que podem ser enchidos com valores de hélio variando entre 1 e N (não se sabe a priori qual o limite), determinar qual o número mínimo de testes que devem ser feitos no pior caso para determinar o ponto em que o balão estoura. Solução: menor valor de i tal que \sum_{j=1}^{k} C(i,j) >= n. Pode-se fazer busca linear ou binária para encontrar o valor de r.
APAGA		- GULOSO 					- remover em ordem os D primeiros elementos que estejam em uma posição i tal que s[i] < s[i+1]. Ao final, imprimir os n-D primeiros elementos da lista. Utilizar lista encadeada para remoção eficiente.
AUTO08		- TRIVIAL					- processar a entrada contando para cada trecho de estrada quantos paineis são necessários.
ARQUIVO		- STRINGS/SUFFIX ARRAY  	- determinar o número de substrings de uma string s (|s| <= 10^5) que aparecem pelo menos duas vezes em s. Solução: constrói-se o suffix array e o vetor LCP (Longest Commom Prefix). Se LCP[i] = k, então o i-ésimo e o (i+1)-ésimo prefixos de s (P1 e P2, considerando os prefixos em ordem lexicográfica) possuem um prefixo de tamanho k em comum, e portanto, P1[0] == P2[0], P1[0:1] = P2[0:1], P1[0:2] = P2[0:2], ..., P1[0:k-1] = P2[0:k-1]. Logo, todas essas k substrings aparecem pelo menos 2 vezes em s. Para contar todas as substrings de s que aparecem pelo menos 2 vezes, basta portanto percorrer o vetor LCP, somando os seus valores na resposta, com o cuidado de não considerar duas vezes a mesma string, ou seja, se LCP[i] = k e LCP[i+1] = k+3, apenas 3 novas substrings devem ser adicionadas na resposta no momento em que LCP[i+1] estiver sendo processado.
BACT09		- MATEMÁTICA, LOGARÍTMOS, BIG INTEGER	- big int = tle. Comparar o tamanho das populações de bactérias usando logarítmos (maior log => maior população).
BAFO		- TRIVIAL 					- imprimir a maior de duas somas
BALDES		- ORDENAÇÃO					- determinar a paridade do número de swaps necessários pra ordenar uma permutação de 1 a N com o bubble sort. Solução: utilizar o bubble sort dá TLE! A paridade do número de swaps do bubble sort é igual à paridade do número mínimo de swaps necessários pra ordenar um vetor, que pode ser calculado em O(n), detectando-se os ciclos da permutação. Uma solução alternativa é utilizar a idéia do merge sort e na operação de merge, ao invés de ordenar, contar o número de inversões que devem ser feitas.
BANFARAO	- ED/SEGTREE/RMQ			- dado um vetor de N inteiros (irrestritos em sinal) e Q queries [a,b], determinar para cada query a soma do intervalo contido em [a,b] com maior soma e o número de elementos desse intervalo. Se existir empate, escolher o intervalo com o maior número de elementos. Solução: adaptação de árvore de segmentos para responder RMQ. Cada nó da árvore armazena 8 tipos de informação sobre o intervalo correspondente: (1) tamanho completo do intervalo, (2) soma total do intervalo, (3) tamanho do sub-intervalo de soma máxima começando na primeira posição do intervalo, (4) soma do sub-intervalo de soma máxima começando na primeira posição do intervalo, (5) tamanho do sub-intervalo de soma máxima terminando na ultima posição do intervalo, (6) soma do sub-intervalo de soma máxima terminando na ultima posição do intervalo, (7) tamanho do sub-intervalo de soma máxima e (8) soma do sub-intervalo de soma máxima. Na hora de construir e fazer queries, utilizar uma operação de join para computar os 8 valores de cada intervalo, a partir dos dois intervalos filhos na árvore.
BAPOSTAS	- GULOSO 					- maximum sum 1D
BATALHA2	- GRID						- dados um tabuleiro de batalha naval e vários lançamentos com posição x, y, determinar quantos navios são completamente destruídos. Solução: busca no grid para identificar todas as posições ocupadas por cada navio, execução dos lançamentos, e porterior verificação pra cada navio original, se todas as suas posições foram atingidas. (http://spojtricks.blogspot.com.br/2014/06/8776-batalha-naval.html)
BIBLIO		- DP						- construir uma árvore binária de pesquisa ótima (OBST). Solução: dp em que o estado dp[i][j] representa a OBST considerando os vértices i,...,j, freq_acc[i][j] representa a frequência acumulada dos vértices i,...,j e dp[i][k] = min{i <= k <= j} dp[i][k-1] + freq_acc[i][k-1] + dp[k+1][j] + freq_acc[k+1][j]. Como os subproblemas são sempre formados por posições contíguas i,...,j, podemos resolver primeiro os subproblemas de tamanho 2, depois 3, até o tamanho n. Os termos freq_acc[i][k-1] e freq_acc[k+1][j] aparecem na recorrência já que podemos ver a operação de escolher o vértice k para ser a raiz da OBST dos vértices i,...,j, é o mesmo que descer um nível as OBSTs dos vértices i,...,k-1 e k+1,...,j.
BICHO		- TRIVIAL					- determinar a premiação de uma aposta no jogo do bicho. 
BIT 		- GULOSO					- problema do troco de moedas 
BORABORA	- SIMULAÇÃO					- simular jogo de baralho com muitas regras. bem chato!
BOLHAS		- ED/SEGTREE/RMQ/ORDENAÇÃO	- dados inteiros N e K, e um vetor v de K inteiros, determinar uma permutação de 1 a N que com exatamente K passagens do bubble sort é ordenada com v[i] swaps na i-ésima passagem. Solução: preencher o vetor solução sol[] com os valores de 1 a N em ordem. Se o número de swaps na i-ésima passagem é v[i], fazer sol[v[i]+1] = i. No caso em que sol[v[i]+1] já foi preenchido, encontrar a primeira posição vazia de sol a partir de v[i]+1 para colocar o valor i. Para fazer isso de forma simples, pode-se utilizar uma árvore de segmentos para responder RMQ. Inicialmente cria-se o intervalo I = [1, 2, ..., N] e toda vez que a posição i de sol é preechida, atualiza-se o valor de I[i] para INF. Se queremos inserir o elemento x na posição i de sol, basta realizar uma query para saber o índice do menor elemento em I de i a N. Complexidade: O(n log n).
BOLSA		- SIMULAÇÃO/ED				- calcular a receita da bolsa de valores considerando o disparo de ordens de compra e de venda e simulando que a todo instante em que é possível realizar uma transação, esta é feita, considerando o cruzamento da melhor ordem de compra com a melhor de venda, com a diferença de preço entre estas ficando como receita da bolsa. Solução: armazenar as ordens de compra e venda em ordem da melhor pra pior (na compra a melhor ordem é a mais alta e na venda a melhor é a mais baixa) e fazer a transação sempre que possível. Uma forma fácil de armazenar as ordens ordenadas é através de um multiset.
BRAIN		- ADHOC						- implementar um interpretador da linguagem brainfuck. A única dificuldade é pra tratar os loops, indicados pelos caracteres '[' (inicia loop) e ']' (termina loop). Podem existir loops aninhados. Os loops foram tratados com recursão.
BSUDO		- BACKTRACKING				- implentar um resolvedor de sudoku. Solução: backtracking. Em toda iteração, fixar todas as casas que só possuem um candidato possível. Depois disso, a casa escolhida pra fixar um candidato no backtracking deve ser aquela que possui o menor número de candidatos, com empates sendo quebrados de qualquer forma. Isso reduz bastante o branching factor e sem essa poda o algoritmo toma TLE. Dica: utilizar máscara de bits pra representar os valores que já foram utilizados em cada linha, coluna e quadrante.
BURACOS		- GRAFOS					- componentes fortemente conectados, dfs
CAIXAS		- AHDOC						- dada um fila de pilhas com caixas empilhadas, determinar o número mínimo de caixas que devem ser desempilhadas até que a caixa 1 possa ser desempilhada. Para que a caixa 1 possa ser desempilhada, basta que todas as caixas acima dela sejam desempilhadas e que todas as caixas à esquerda ou à direita dela na fila, em uma altura igual ou superior, também sejam desempilhadas. Seja P a pilha onde está a caixa 1 e A a sua altura. Se P1 é a última pilha antes da pilha P que tem altura < A, não é necessário considerar as pilhas antes da pila P1, inclusive. Da mesma forma, se P2 é a primeira pilha depois da pilha P que tem altura < A, não é necessário considerar as pilhas posteiores a P2, inclusive.
CAIXEIRB	- GRAFOS					- determinar o tamanho do menor caminho de um caixeiro viajante tendo que visitar apenas alguns vértices de uma árvore. Solução: dfs
CAIXEIRO	- GRAFOS + LIS				- dada uma árvore e uma lista de vértices L que se deseja visitar, determinar o tamanho do caminho que se origina na raiz da árvore (vértice 0) vai até um outro vértice qualquer e volta para a raiz da árvore que passa pelo maior número de vértices de L, na mesma ordem. L pode conter vértices repetidos, que podem ser considerados mais de uma vez no tamanho da sequência, se o caminho escolher ficar parado em algum vértice durante algum tempo. Solução: Para cada caminho C entre a raiz e uma folha, determinar uma LIS em uma sequência S construída a partir de C e L. A maior LIS é a resposta. Ex: C = {0,1,7,1,0} e L = {0,7,6,7,1,6,5,2,1}. A sequência S é formada pelos índices das posições em que cada elemento de C aparece em L. S = {0, 4,8, 1,3, 4,8, 0}.
CALCU11		- MATEMÁTICA, FATORAÇÃO, BIG INTEGER	- calcular o produto armazenando apenas o indice dos fatores primos.
CALCUL11	- MATEMÁTICA, FATORAÇÃO, BIG INTEGER	- calcular o produto armazenando apenas o indice dos fatores primos. (problema repetido CALCU11) 
CALCULA		- TRIVIAL 					- ler uma expressão matemática apenas com os operadores da soma e da subtração, com os operando sendo apenas inteiros, e imprimir o resultado
CARDAPIO 	- GRAFOS					- apenas responder se uma expressão 2-sat é satisfazível ou não - resolução com algoritmo de tarjan para componentes fortemente conectados
CARTOG11	- estouro de pilha, grafos, árvore	- Diâmetro de um grafo. (http://spojtricks.blogspot.com.br/2014/05/11011-desafio-cartografico.html)
CAVALOS 	- GRAFOS 					- fluxo máximo
CEBOLA		- GEOMETRIA 				- dado um conjunto de pontos no plano, contar quantas envoltórias convexas cobrem todos esses pontos. Solução: como os limites são baixos, pode-se calcular o convex hull, retirar os seus pontos, e continuar esse processo até que sobrem menos de 3 pontos. O número de iterações desse processo é a resposta. 
CELETRIC	- BUSCA BINÁRIA				- dados um inteiro A representando a soma dos preços de duas contas de eletricidade se elas fossem consideradas apenas uma, e um inteiro B representando a diferença no preço pago por cada conta se essas fossem consideradas contas separadas, a partir de uma tabela fixa com o preço que se paga por cada watt/hora em cada faixa de consumo, determinar o preço R correspondente à conta mais barata. Solução: a partir da tabela de valores, criar funções para saber o preço de X watt/hora e saber quantos watt/hora equivalem a Y reais, calcula a soma W do consumo em watt/hora das duas contas e fazer busca binária na resposta R, com a primeira conta pagando R e a segunda pagando R + B. Verificar se a soma dos consumos correspondentes a esses dois preços é igual a W. Fazer todas as operações com números em ponto flutuante.
CHAMADA1	- ORDENAÇÃO					- determinar o k-ésimo menor elemento de um conjunto
CFATORES	- MATEMÁTICA 				- contar o número de fatores primos distintos de um inteiro
CHOCPJ09	- MATEMÁTICA, ARITMÉTICA MODULAR, PD	- 
CHUVA11		- TRIVIAL, SOMA DE MATRIZ	- soma de matrizes.
CIPO 		- GRAFOS 					- árvore geradora mínima com algoritmo de kruskal e ordenando as arestas em O(m)
CIRCUITO	- TRIVIAL					- dada uma matriz binária, determinar quantas vezes o número de elementos consecutivos iguais a 1 em uma coluna é maior ou igual a um parâmetro de entrada.
CLUBE		- ADHOC, GULOSO				- tente dispor as tabuas das duas formas possíveis no salão.
COFRE		- TRIVIAL 					- imprimir a diferença entre duas somas parciais
COLOR11		- BSF						- busca em largura em uma imagem quadriculada.
COMETA2		- MATEMÁTICA				- trivial, aritmética modular
CONCAMEL	- DP						- dada uma expressão de inteiros com operandos de 1 a 20 e operadores + ou *, determinar qual a parentização que confere o valor máximo e a que confere o valor mínimo para a expressão. Solução: mesma ideia do matrix chain multiplication, resolvendo primeiro os problemas contíguos de menores tamanhos, com equação de recorrência: dp[i][j] = max/min_{i<=k<=j-1} dp[i][k] [+*] dp[k+1][j]
CONTA1		- TRIVIAL					- adhoc
CONTAGEM 	- ADHOC 					- contagem
CONTRATO	- TRIVIAL					- remover toda ocorrência do caractere c de uma string s e imprimir a string resultante
COPA		- TRIVIAL 					- dada a pontuação de N times em um campeonato com pontuação normal (3 pts pra vitória, 1 pro empate e 0 pra derrota) e o número P de partidas realizadas, determinar quantos empates ocorreram. Solução: 3*P - SOMA_PTS_TIMES
COPA1		- ADHOC						- dados os resultados dos 15 jogos eliminatórios da copa do mundo, determinar o campeão
CORR11		- ORDENAÇÃO					- ordenação
CORRID11	- ORDENAÇÃO					- ordenação
CPCARROS	- ADHOC 					- conversão de bases. Dadas duas placas de trânsito, que podem estar em dois diferentes formatos (AAA0000 ou AAAAA00), determinar a "distância" entre elas. Algumas letras não são válidas para as placas do segundo formato. Solução: Algoritmo para conversão de base, com cuidado especial para tratar as letras inválidas! 
CRIPTO		- ORDENAÇÃO/CRIPTOGRAFIA	- descriptografar uma mensagem criptografada utilizando o método de substituição com contagem de frequência: a letra mais frequente na mensagem é a letra mais frequente no alfabeto, e assim por diante, com desempate quebrado pela ordem alfabética. 
CUBO		- GRID/BFS					- dado um grid com posições bloqueadas e posições livres, a posição inicial de uma pessoa, a posição inicial de uma caixa, e a posição em que a caixa deve ser colocada, respeitando a condição de que a caixa pode ser movida de uma célula i para uma célula k (por exemplo, k = i+1), vizinha de i, na direção ik se a pessoa estiver numa célula j (no caso, j = i-1), vizinha de i, e a direção ik for igual à direção ji, determinar o menor número de movimentos da pessoa e da caixa para que a caixa vá da posição inicial para a final. Deve-se minimizar primeiro o número de movimentos da caixa e no caso de empate o número de movimentos da pessoa. Solução: bfs em que o estado é dado por um hash do x e y da pessoa e do x e y da caixa. A fila da busca em largura deve ser uma fila de prioridade, retirando primeiro quem tem a menor distancia percorrida pela caixa e no caso de empate a menor distancia percorrida pela pessoa. No instante em que a caixa chega no destino final, temos a resposta ótima.
CUBOS		- ADHOC/ED					- dado uma lista de N cubos definidos pela cor de cada um de seus 6 lados (cores variam de 1 a 9), determinar o número de cubos distintos, tal que dois cubos são considerados iguais se for possível rotacionar um deles de forma que as cores nas faces respectivas dos dois cubos sejam iguais. Solução: podemos definir uma representação única pra cada cubo, e colocar todos os cubos em um set, imprimindo ao final o tamanho do set. Uma forma de representar um cubo é através dos ids do menor par de faces opostas e dos ids das outras 4 faces seguindo o sentido horário ou anti-horário, armazenando esses ids com a menor rotação lexicográfica. A representação considerando apenas as três faces opostas, sem considerar o sentido delas não é válida.  
DAMA		- ADHOC 					- determinar o número mínimo de movimentos que uma dama precisa fazer para ir de uma posição a outra em um tabuleiro de xadrez. Solução: a resposta é sempre 0, 1 ou 2
DANCA		- ADHOC/SIMULAÇÃO/ED		- dado um anel com N posições, em que inicialmente K delas são ocupadas com objetos girando ou no sentido horário ou anti-horario, e considerando que a cada iteração cada objeto anda uma unidade para o sentido em que está apontando, determinar o número mínimo de iterações tal que o conjunto de objetos passe a ocupar exatamente as mesmas posições da configuração inicial. Cada objeto não precisa voltar para sua posição de origem, mas precisa ocupar a posição de origem de algum outro objeto. Solução: como as posições ocupadas devem ser as mesmas, o objeto 1 deve ocupar alguma das posições ocupadas inicialmente por algum dos objetos de 2 a K. Portanto, basta verificar qual o deslocamento para o objeto 1 sair de sua posição inicial e ir para a posição i, realizar o mesmo deslocamento com todos os demais objetos (respeitando a orientação de cada um) e em seguida verificar se o conjunto das novas posições ocupadas é o mesmo conjunto de posições ocupadas inicialmente.
DECADARI	- ADHOC 					- regra de 3
DENGUE		- GRAFOS 					- encontrar o diâmetro e o(s) vértice(s) central(is) de uma árvore. Solução: Seja v0 um vértice qualquer, v1 o vértice mais distante de v0 e v2 o vértice mais distantes de v1. O diâmetro da árvore é formado pelo único caminho que conecta v1 a v2, que podem ser descobertos com duas buscas no grafo, a partir de v0 e v1. O vértice no meio desse caminho é o vértice central da árvore. Complexidade: O(n). Nesse problema, o algoritmo direto O(n^2) que calcula a distância entre todo par de vértices (i, j) passa no tempo devido ao limite n <= 100.
DEPENDEN	- GRAFOS					- verificar qual o vértice em um grafo direcionado é a raíz da maior arborescência em número de vértices. Solução: rodar uma dfs para cada vértice i contando o número de vértices visitados na arborscência enraizada por i.
DESCULPA	- DP 						- mochila 0-1
DESFILE		- ADHOC						- Encontrar o elemento mais frequente em um array
DESVIO		- GRAFOS					- dado um grafo direcionado, um vértice origem s e um vértice destino t, com a restrição que entre vértices do conjunto S = {0, 1, ..., C-1} só podem existir arestas do vértice i pro vértice i+1, determinar o menor caminho entre s e t. Solução: dijkstra no grafo do problema. A montagem do grafo é simples: se uma aresta de entrada incide em um vértice de S e em um vértice fora de S, cria-se um arco orientado apenas do vértice de fora de S para o vértice de dentro de S. Se a aresta incide em dois vértices a e b de S, cria-se um arco de a para b apenas se b == a+1. Se a aresta incide em dois vértices fora de S, cria-se dois arcos conectando esses dois vértices, um em cada sentido.
DINOSTRA 	- ADHOC
DIOFANTO	- MATEMÁTICA 				- dados inteiros N e C, determinar quantas soluções módulo um PRIMO inteiras não-negativas existem para a equação x_1 + x_2 + ... + x_N = C. A resposta é dada pela solução de Combinação(N+C-1, C) mod PRIMO. Sabe-se que C(n,k) % p = (n)! / ((n-k)! * k!) % p = n! * (n-k)!^{-1} * k!^{-1} % p. Como p é primo, gcd(a!, p) = 1, para todo a, e pode-se calcular o inverso multiplicativo modular de a! utilizando, por exemplo, o algoritmo de Euclides estendido. Outra forma de calcular o inverso multiplicativo de a é baseada no fato de que a^(p-1) = 1 (mod p) -> a * (a^(p-2)) = 1 (mod p) -> a^{-1} (mod p) = a^(p-2) (mod p).
DOCE		- DP 						- dada uma matriz de inteiros positivos, escolher o subconjunto de elementos dessa matriz cuja soma seja máxima, com a restrição de que se a posição (i,j) for escolhida, nenhuma outra posição das linhas i-1 e i+1 poderá ser escolhida assim como as posições (i,j-1) e (i,j+1). Solução: redução do problema de 2 dimensões para 1 dimensão. Resolve-se o problema de forma independente para cada linha, calculando-se a soma máxima que pode ser obtida em um vetor sem poder escolher elementos consecutivos. Para tanto, pode-se utilizar uma dp com complexidade de tempo O(n) em que o estado d[i] é um pair<int,int> em que dp[i].first armazena a resposta ótima considerando a escolha do elemento i e a melhor escolha dos elementos de 0 a i-2 e dp[i].second armazena a resposta ótima considerando a não escolha do elemento i e a melhor escolha dos elementos de 0 a i-1. A solução ótima do problema global é dada pela soma das soluções ótimas dos problemas definidos para cada linha, e pode ser resolvido com o mesmo algoritmo de dp.
DOBRA		- DP						- dp simples de deduzir com pequenos casos de teste mas difícil de pensar combinatorialmente. Problema: seja D uma operação de dobrar um quadrado ao meio duas vezes (uma na vertical e outra na horizontal). Após realizar N vezes a operação D e recortar o quadrado resultante duas vezes (uma na vertical e outra na horizontal), quantos quadrados existirão?
DOMINO		- BACKTRACKING				- dada a configuração de uma matriz 7x8 com 56 valores de peças de dominó, determinar de quantas maneiras diferentes é possível colocar as 28 peças de dominó na matriz de acordo com os valores dados. Solução: backtracking. Para cada peça, cria-se uma lista de posições que essa peça pode ocupar. No backtracking, cada uma dessas posições é um candidato viável. obs: ordenar as peças pelo menor número de candidatos, apesar de reduzir o branching factor, aumenta o tempo de execução. O overhead da ordenação é mais caro do que a economia com as podas no backtracking. 
DUENDE		- GRAFOS					- bfs, encontrar caminho mínimo em um grid em que algumas células não podem ser visitadas. O estado é formado pelo par (posição, distância).
ELASTICO	- GEOMETRIA + PD			- dado um conjunto de pontos no plano, determinar o maior número de vértices que podem ser utilizados para formar um polígono convexo. Solução: Ordenação radial e depois PD em que o estado pd[i][j] é igual ao número máximo de vértices de um polígono convexo formado pelos pontos {0, ..., i, j, 0} e transição: pd[i][j] = max_{k<i} pd[k][i] + 1, se os pontos k, i e j estiverem orientados no sentido anti-horário, ou seja, se o produto vetorial entre os vetores (k-j) e (i-j) for positivo.
ELEICOES	- TRIVIAL 					- determinar qual o número que aparece mais vezes em uma lista. Utilizei unordered_map (hash table)
ELETRICI	- TRIVIAL 					- dada uma lista em que cada elemento é representado por uma data e o consumo de energia até aquela data, calcular a soma do consumo relativo aos dias consecutivos da lista. É necessário apenas tratar ano bissexto e saber qual o dia seguinte de um determinado dia.
ELEVADO2	- TRIVIAL					- dada a capacidade de um elevador, e o número de pessoas que entram e saem em cada andar, determinar se em algum instante a capacidade do elevador foi excedida
ELEVADOR	- GEOMETRIA					- dados um retângulo e dois círculos, determinar se os dois círculos cabem dentro do retângulo sem sobreposição.
ENCOTEL		- ADHOC 					- sistema de codificação trivial
ENERGIA		- GRAFOS 					- union find
ENGARRAF	- GRAFOS 					- caminho mínimo entre origem e destino. Solução: dijkstra em O(n log n)
ENVEL09		- ADHOC, TRIVIAL			-
ESCALO11	- GRAFOS, ORDENAÇÃO TOPOLÓGICA	- ordenação topológica.
ESPIRAL		- MATEMÁTICA/BUSCA BINÁRIA	- determinar a linha e a coluna de um índice dado em um grid espiral. Solução: achar fórmulas fechadas pros elementos das diagonais do grid, determinar qual a distância (quadrado ao redor do centro) do índice dado para o centro do grid (pode ser feito com busca binária), e depois calcular as linhas e colunas em função das posições extremas do quadrado dado pela distância.
ESTAGIO		- TRIVIAL 					- imprimir todos os elementos máximos de um vetor
EXPRES11	- PILHA						- Empilhe se ler {{( e desempilhe se }]) verificando se o topo da pilha faz par com o caractere atual.
F91 		- ADHOC						-
FATORIA2	- ADHOC						- calcula fatorial de n.
FATORIAL 	- ADHOC 					- determinar o dígito mais a direita de n! (n <= 1000000)
FATORA2		- TRIVIAL 					- imprimir N! (0 <= N <= 12)
FEYNMAN		- MATEMÁTICA 				- problema: quantos quadrados existem em um grid N*N? solução: 1^2 + 2^2 + ... + N^2
FLIPERAM	- TRIVIAL 					- imprimir os K menores elementos de um vetor
FLOREST2	- MATEMÁTICA/CONTAGEM		- determinar quantas soluções existem pra equação a*b + (a-1)*(b-1) = n. Solução: reescrevendo a equação temos: a = (n+b-1)/(2b-1). Como n <= 10^9, podemos testar todos os valores inteiros de a para os quais b assume valor inteiro com complexidade O(sqrt(n)). 
FORMULA		- TRIVIAL					- determinar os vencedores de um campeonato de Fórmula 1 dada a classificação nas corridas de cada piloto e o sistema de pontuação
FROTATAX	- ADHOC 					- dado o preço da gasolina e do álcool, e a quantidade de km/litro de cada um, determinar qual é o mais vantajoso (econômico)
FUGIT09		- SIMULAÇÃO					- calcule a distância a cada passo e verifique se ela é menor que a distância máxima.
FUROS		- GEOMETRIA					- dado um conjunto de pontos no plano, determinar aquele ponto que está a uma distância mínima do ponto mais distante. Solução: como o número máximo de pontos é 1000, o algoritmo O(n^2) de testar todos os pontos i e a distância dos demais pontos pra i passa no tempo!
FUSOES1		- GRAFOS					- union find
FUTEBOL		- ORDENAÇÃO					- imprimir tabela de classificação de um campeonato de futebol
GALOUVOL	- GRID/DFS/BFS				- dado um grid hexagonal, em que cada célula pode conter uma roda dentada girando no sentido horário, anti-horário, ou bloqueada, determinar a configuração final das rodas dentadas a partir de um conjunto de regras. Solução: para cada célula do grid, aplicar as alterações necessárias nos estados das células vizinhas, até que nenhuma célula do grid seja alterada. Dá pra fazer de forma mais eficiente com uma bfs ou dfs.
GENEAL		- GRAFOS					- determinar o tamanho e os dois vértices extremos do diâmetro de uma árvore. Solução: duas bfs
GINCAN11	- CONJUNTOS, DIJOIT SET		- Contar o número de conjuntos.
GUERRA		- GEOMETRIA 3D				- determinar a distância mínima entre dois tetraedros. Solução: menor distância entre cada aresta do tetraedro 1 e cada aresta do tetraedro 2 ou cada ponto de um tetraedro com cada plano (triângulo) do outro tetraedro.
HIST		- ADHOC 					- dada uma lista com as posições de comandos no histórico de comandos, determinar o número total de vezes que a tecla '^' deverá ser executada para executar todos os comandos 
HONESTID 	- MATRÓIDES 				- instersecao de dois MATRÓIDES - um matróide gráfico e outro matróide de partição
HOOLIGAN	- GRAFOS					- dados três inteiros N(número de times de um torneio de futebol), M (jogos entre cada par de times) e G (número de jogos já realizados), e a lista de jogos realizados, em que a vitória vale 2 pontos, o empate vale 1 ponto e a derrota vale 0 pontos, determinar se existe uma configuração de valores pros jogos restantes tal que o time 0 seja o campeão isolado (segundo colocado com estritamente menos pontos). Solução: modelagem como um problema de fluxo máximo em grafos. Cria-se um grafo bipartido em que a primeira partição P representa as partidas restantes e a segunda partição T representa os times, com um nó source conectado a todos os vértices de P com capacidade 2 (número de pontos distribuídos por cada partida) e com todos os vértices da partição T conectados a um nó sink, com capacidade pts[0]-pts[i]-1, em que pts[i] é o número de pontos do time i (assumi-se que o time 0 ganhou todas as suas partidas restantes). Cada vértice da partição P se conecta a dois vértices da partição T, com capacidade igual a 2 nas duas arestas. Assim, existe uma configuração de resultados pras partidas restantes que tornam o time 0 campeão isolado se e somente se o fluxo máximo do source pro sink for igual ao número de pontos que ainda devem ser distribuídos nas partidas restantes. Importante verificar antes da execução do fluxo máximo se algum time já possui pontuação igual ou superior à máxima pontuação do time 0, caso em que a resposta para o problema é Não.
IMPEDIDO	- TRIVIAL					- dadas as posições de jogadores em um campo de futebol em relação à linha de fundo, determinar se algum jogador de um dos times está impedido. Solução: basta contar quantos jogadores do time defensor estão em posição mais próxima da linha de fundo que o jogador mais próximo da linha de fundo do time que está no ataque. Se for pelo menos 2 jogadores, não há impedimento.
IREVIR		- GRAFOS					- verificar se um grafo direcionado é fortemente conectado
IRMAOS		- GRID/SIMULAÇÃO			- dada a configuração inicial de um grid de inteiros, determinar a configuração final do grid após K ataques. Em cada ataque, se a célula (i,j) é ocupada pelo inteiro n, as células (i+1,j), (i-1,j), (i,j+1) e (i,j-1) que forem ocupadas pelo inteiro n+1 passam a ser ocupadas pelo inteiro n. Solução: simular os K ataques
ISOSCELE	- GEOMETRIA					- dados N pontos no plano, sem que hajam quaisquer três pontos colineares, determinar quantos triângulos isósceles podem ser formados. Solução: para cada ponto, calcula a distância dele pros demais pontos e pra cada distância que aparece K (K>=2) vezes, somar na resposta K*(K-1)/2. Fazer a contagem com map dá TLE. Fazer com unordered_map passa mas fica com tempo bem ruim. O mais eficiente é colocar tudo em um vetor, ordenar e depois fazer a contagem. Reduz o tempo de 17s (unordered_map) para 7s (array + sort).
ITMIHA		- MATEMÁTICA/BUSCA BINÁRIA	- um número é considerado ser um número de it-miha se não possui como divisor algum quadrado perfeito distinto de 1. Os primeiros números de it-miha são {1, 2, 3, 5, 6, 7, 10, 11, 13, 14}, que não são divisíveis nem por 2^2=4 nem por 3^2=9. Dado um inteiro n, deseja-se determinar o n-ésimo número de it-miha. Solução: Dado um inteiro K, se soubermos calcular quantos números de it-miha existem menores ou iguais a K, saberemos resolver nosso problema original com uma busca binária em K. Para fazer a contagem, primeiramente geramos com o crivo os quadrados perfeitos dos primeiros número primos e utilizamos o princípio da inclusão-exclusão, que pode ser implementado facilmente de forma recursiva. Considere que todos os quadrados perfeitos dos números primos estejam armazenados no array squares[]. Seja f(n,i) o número de inteiros menores ou iguais a n que possuem algum squares[j] (j >= i) como divisor. O número de it-mihas menores ou iguais a n é igual a: n - f(n,0), onde f(n,i) = \sum_{i=0}^{j} n/squares[i] - f(n/squares[i], i+1), tal que j é o maior valor para o qual squares[j] <= n.
JASPION		- TRIVIAL 					- tradutor do japonês pro português. Solução: map< string, string >
JDENTIST	- GULOSO					- dadas N atividades descritas pelo instante de início e de fim, determinar qual o número máximo de atividades que podem ser realizadas sem conflito. Solução: guloso, ordenação das atividades pelo instante de fim e depois ir selecionando as atividades para serem executadas de forma gulosa sempre que possível
JESCADA		- TRIVIAL 					- dados dois inteiros A e B, imprimir A - B
JGARCOM		- TRIVIAL 					- dados dois vetores A e B, imprimir a soma de todo B[i] tal que B[i] < A[i]
JINGLES		- MATEMÁTICA				- dadas as durações de cada nota musical (1 / 2^i, i = {1,...,6}), determinar quantos compassos são bem formados (duração igual a 1). Solução: mais fácil trabalhar apenas com inteiros, bastando considerar as durações multiplicadas por 64 e verificar se a soma do tempo de cada compasso é igual a 64.
JPNEU		- TRIVIAL 					- dadas N atividades descritas pelo instante de ínicio, todas com duração igual a 10 unidades de tempo, determinar qual o número de instantes de tempo em que pelo menos uma atividade está ocorrendo. Solução: como os limites são baixos, pode-se criar um vetor de bool para indicar se há ou não atividade em um determinado instante de tempo
JSEDEX		- TRIVIAL 					- dados os inteiros A, B, C e D verificar se A é menor B, C e D
JTACOGRA	- TRIVIAL 					- imprimir o produto escalar de dois vetores
JUNINA		- BACKTRACKING 				- conjunto independente de vértices de máxima cardinalidade em um grafo com no máximo 20 vértices. obs: as soluções sem cortes que utilizam manipulação de bits para gerar todos os conjuntos levaram TLE, mesmo quando esses conjuntos são gerados do maior para o menor em relação à cardinalidade.
KLINGON		- BUSCA BINÁRIA/LINEAR		- dados N vetores de inteiros, seja a(i,t) o número de elementos do vetor v[i] maiores ou iguais a t, b(i,t) o número de elementos do vetor v[i] menores que t e f(i,t) = |a(i,t) - b(i,t)|. Deseja-se determinar o valor T entre 0 e 1000 que minimize \sum_{i = 1}^{N} f(i,T). Solução: ordenar cada um dos N vetores, fazer uma busca linear na resposta e para cada um dos valores de T fazer busca binária em cada vetor i pra contar a(i,T) e b(i,T).
KRAKOVIA	- BIG INTEGER				- fazer soma e divisão de números inteiros grandes (não cabem em 64 bits)
KOCH		- PD/CICLOS					- determinar os 3 últimos dígitos do k-ésimo número de fibonacci (k <= 10^1000000). Solução: determinar ciclo dos últimos 3 dígitos da sequência de fibonacci (por exemplo, com um set< pair< int, int > >) e depois descobrir a posição de k no ciclo. O ciclo tem tamanho exatamente igual a 1500 e começa a se repetir desde a posição 0, ou seja, fib[1500] == fib[0], fib[1501] == fib[1], etc. Resta então apenas calcular k % 1500. Para isso, pode-se usar a regra de Horner, da esquerda para a direita, sempre mantendo apenas o resultado módulo 1500.
LASERR		- ADHOC						- solução com algoritmo O(n) em um problema que aparenta ser mais difícil
LCAIXA		- DP						- dado um conjunto de inteiros V, determinar se existe uma atribuição de sinais aos elementos de V tal que a soma seja igual a F. No caso de existir, deve-se determinar se em todas as atribuições possíveis, o i-ésimo elemento sempre fica com o sinal '+', ou sinal '-', ou pode assumir qualquer um dos dois sinais. Soluçao: transformar o problema na resolução de vários problemas coin change. A transformação pode ser feita a partir da observação a seguir. Seja V um conjunto de números inteiros positivos, S(V) a soma dos elementos do conjunto V e F o valor alvo. Teorema: Existe uma atribuição de sinais aos elementos de V tal que S(V) = F se e somente se existe um subconjunto V' de V tal que S(V') = (S(V)-F)/2. Prova: Se trocamos o sinal positivo de um numero V_i do conjunto V pelo sinal negativo, a nova soma total será igual a S(V) - 2*V_i. Logo, se existir um conjunto V' tal que S(V) - 2*S(V') = F, então é possível atribuir sinais negativos a alguns valores de V, resultando no conjunto V'', tal que S(V'') = F.
LOGOTIPO	- STRING MATCHING			- casamento de padrões em matriz 2d.
LOOPMUSI	- TRIVIAL 					- determinar quantas posições i de um vetor circular são tais que ou v[i-1] < v[i] > v[i+1] ou v[i-1] > v[i] < v[i+1]
LOTERIA		- TRIVIAL 					- dado um conjunto de inteiros entre 1 e K, determinar todos os inteiros entre 1 e K que aparecem o menor número de vezes.
LOTICA		- TRIVIAL					- determinar se existe mais de uma posição em um vetor de 5 elementos com valor <= 127. Se existir apenas uma, dizer qual é esta posição.
LUA			- TRIVIAL 					- determinar qual a maior e a menor média inteira de K posições consecutivas de um vetor de tamanho N (N >= K)
MACACO 		- ADHOC						-
MAGICO11	- ADHOC						-
MANUT		- GRAFOS					- encontrar pontos de articulação 
MAPAS		- ADHOC/ED/BUSCA BINÁRIA	- dado um conjunto de M <= 30000 retângulos (x1, y1, x2, y2) com coordenadas -10000 <= x1, x2, y1, y2 <= 10000, e um conjunto de R (<= 50000) queries (x, y), retornar qual o "melhor" retângulo que ocupa a célula (x,y), em que "melhor" é definido como: menor área, centro mais próximo de (x,y) e menor id, nesta ordem. Existem no máximo n = 500 valores distintos para x e para y. Solução: compressão de coordenadas, que pode ser feita armazenando cada retângulo em uma estrutura do tipo map< int, map< int, map< int, map< int, ret > > > >, agrupando pelas coordenadas x1, x2, y1 e y2, respectivamente. Para cada query (x,y), só é necessário verificar os retângulos que possuem x1 <= x, x2 >= x, y1 <= y e y2 >= y. Os índices que delimitam essas condições na estrutura de dados criada podem ser encontrados com busca binária em O(log n), com as funções lower_bound e upper_bound da STL, de modo que apenas retângulos que satisfazem as 4 condições são analisados.
MARAT09		- ADHOC, TRIVIAL			-
MARCIAN1	- GEOMETRIA					- dadas as dimensões de uma caixa e o raio de uma esfera, determinar se a caixa cabe dentro da esfera. Solução: apenas verificar se a diagonal da caixa é menor ou igual a duas vezes o raio
MARIENBA	- JOGOS						- nim clássico com exceção de quando todas as pilhas tem tamanho 1, caso em que a resposta é a contrária.
MARIO		- BUSCA BINÁRIA				- dados um inteiro N e uma lista crescente de inteiros de tamanho L, com cada inteiro com valor <= 10^9, determinar qual a faixa de inteiros contíguos [i, i+1, ..., i+N-1] que possui o maior número de elementos em L. Solução: Para cada inteiro i da lista, contar quantos inteiros existem na lista maiores ou iguais a i e menores ou iguais a i+N-1. Isso pode ser feito em O(log n) com a função upper_bound da STL.
MATRIZ2		- MATEMÁTICA				- dados parâmetros que definem as entradas de duas matrizes A e B, determinar o valor de uma célula C[i][j] da matriz C = A * B. Solução: Como a dimensão das matrizes A e B pode ser 10^5, não é possível nem criar as matrizes. Portanto, deve-se apenas considerar a linha relevante de A (linha i) e a coluna relevante de B (coluna j) para encontrar o valor de C[i][j] fazendo o produto escalar da linha i de A com a coluna j de B.
MCAIRO		- BUSCA BINÁRIA/BIT 2D		- dada uma sequência S de n pontos no plano representados pelas coordenadas x e y, determinar qual a maior subsequência crescente desses pontos, considerando que o ponto p1 é posterior ao ponto p2 se e somente se p1.x >= p2.x E p1.y >= p2.y. Solução: esse problema pode ser visto como o LIS em duas dimensões. Portanto, pode-se pensar em uma ideia semelhante ao LIS 1D. Como os elementos de S formam um conjunto *parcialmente* ordenado, ou seja, não existe uma relação de precedência entre quaisquer dois pares de elementos (por exemplo, (1,4) e (2,3)), o algoritmo clássico para resolver o LIS 1D em O(n log n) não funciona. No entanto, uma variação dele, que separa os elementos da sequência de entrada em níveis, é capaz de resolver o problema em O(n log n log m), em que m é o tamanho da resposta. Para tanto, os pontos de cada nível são armazenados em ordem, removendo-se todos os pontos dominados de um nível sempre possível. Um ponto p2 é dominado pelo ponto p1 se p2 >= p1. Dessa forma, todos os pontos de um nível, estarão ordenados de forma que a sequência de suas coordenadas x é sempre crescente e de suas coordenadas y é sempre decrescente. Quando um novo ponto p é processado, ele é colocado no maior nível i tal que exista algum ponto no nível i-1 que tenha coordenadas x e y menores ou iguais às coordenadas correspondentes do novo ponto. Para determinar o nível em que o ponto p será colocado, pode-se utilizar uma busca binária com complexidade O(log m). Para verificar se existe algum ponto no nível i menor ou igual a p, basta fazer uma busca binária (lower_bound) no nível i em O(log n), procurando pelo primeiro ponto maior ou igual a p (seja esse o ponto r). Se o ponto anterior a r (seja esse o ponto q) na sequência ordenada de pontos do nível i, for tal que q <= p, então existe pelo menos um ponto no nível i (seja este o ponto q) que domina o ponto p, e portanto, p pode ser colocado na pior das hipóteses no nível i+1. Se não existir em ponto q no nível i, tal que q <= p, então q pode ser colocado no máximo no nível i. Ao final do algoritmo, o número de níveis é igual ao tamanho da maior LIS 2D. É também possível resolver esse problema utilizando BIT 2D.
MEGADAMA	- BACKTRACKING				- dado uma configuração de um tabuleiro de dama, determinar o número máximo de peças do adversário que o jogador 1 pode comer em apenas uma jogada. Solução: backtracking 
MESA 		- GRAFOS 					- BFS para verificar se grafo é bipartido
METEORO		- TRIVIAL 					- imprimir quantos pontos inteiros 2D estão dentro de um retângulo dado pelas 4 extremidades
MINADO12	-							-
MINIMO 		- GRAFOS 					- caminhos mínimo entre um par de vértices (o,d) passando apenas por vértices de índice menor que t - adaptação do floyd-warshall
MINHOCA		- TRIVIAL 					- determinar a soma máxima de uma linha ou coluna de uma matriz de inteiros
MINHOCA2	- DP						- dada uma matriz NxM de inteiros positivos e negativos, determinar a soma do caminho iniciando na célula (0,0) e terminando na célula (N-1,M-1) com soma máxima, considerando que só é possível caminhar para baixo, esquerda ou direita. Solução: pd O(n^2). Na primeira linha só é possível ir para a direita. Nas demais linhas, fazer uma pd da esquerda para a direita e outra da direita para a esquerda, e por fim pegar o máximo para cada célula vindo ou de cima, ou da esquerda ou da direita.
MIOJO		- MATEMÁTICA 				- descobrir a solução da equação linear diofantina da forma ax + by = c, tal que max(ax, by) seja mínimo. É necessário usar long long
MITO09		-							-
MOEDAS		- DP 						- coin change, minimizar número de moedas para atingir um determinado valor
NATUREZA	- GRAFOS 					- determinar o tamanho da maior componente de um grafo não direcionado. Solução: dfs ou union find
NLOGONIA	- TRIVIAL 					- determinar se um ponto está ao nordeste, noroeste, sudeste ou sudoeste de um ponto referência
NUMERDOS	- GRAFOS 					- dada uma lista de papers com seus respectivos autores, determinar o número de Erdos de cada autor. Solução: montar o grafo e executar uma bfs calculando a distância mínima de todos os vértices a partir do vértice correspondente ao autor P. Erdos.
OBIDOMIN	- GRAFOS 					- dado um conjunto de peças de dominó, determinar se é possível colocar todas elas em sequência seguindo a regra do jogo de dominó. Solução: verificar se existe um circuito ou caminho euleriano (grafo conexo e grau de todos os vértices é par ou o grau de apenas dois vértices é ímpar) no grafo com conjunto de vértices {0, 1, ..., 6} e conjunto de arestas dado pelas peças do dominó. Erro: esqueci de considerar que apenas os vértices com grau > 0 (aqueles que aparecem pelo menos uma vez na entrada) devem ser considerados. Portanto, a dfs que verifica se o grafo é conexo deve iniciar a partir de um vértice com grau > 0.
OBIHANOI	- ADHOC 					- imprimir o número de movintos necessários para transferir N discos da coluna inicial para a final. Solução: 2^N-1
OBIPOKER	- ADHOC 					- determinar a pontuação de uma mão em um jogo de poker adaptado
OBITETRI	-							-
ODDOREVEN	- TRIVIAL 					- dados fora de ordem os valores escolhidos por 2 jogadores A e B em N partidas de pár-ou-ímpar e sabendo-se que o jogador A sempre escolheu par, determinar o número mínimo de partidas que o jogador A venceu. Solução: min( even_A, odd_B ) + min( odd_A, even_B )
OLIMP		- GRAFOS 					- dada uma rede direcionada capacitada, um nó de origem, um nó de destino, e um fluxo inteiro F, determinar o número mínimo de unidades de tempo necessárias para trafegar F da origem para o destino, considerando que cada unidade de fluxo pode percorrer apenas uma aresta em 1 unidade de tempo. Solução: Adaptação do algoritmo de fluxo máximo de caminhos aumentantes.
OLIMP09		-							-
OLIMPJ09	-							-
ONZE		- ADHOC 					- determinar se um número de 1000 caracteres é múltiplo de 11. Solução: Um número é divisível por onze se e somente se a soma dos algarismos de posições pares e a soma dos algarismos de posições impares tiverem o mesmo resto da divisão por onze.
ORKUT		- GRAFOS					- ordenação topológica. grafo com o label de cada vértice sendo uma string
OUTRACRI	- GRAFOS					- dada uma topologia de árborescência e um inteiro T representando que se T% dos filhos de um nó forem ativados o nó pai é também é implicitamente ativado, determinar qual o número mínimo de nós na arborescência que devem ser explicitamente ativados para que o nó raíz da árvore seja implicitamente ativado. Solução: função recursiva para cada nó que retorna o número mínimo de vértices na sub-árvore enraizada nele que devem ativados para que ele seja implicitamente ativado. Para tanto, basta pegar as respostas para os filhos (1 pra nós folha), ordenar em ordem crescente, e escolher os menores até que T% dos nós filhos estejam ativados. 
OVERF09		-							-
PAL			- DP 						- determinar o menor número de partes em que uma string pode ser dividida tal que todas as partes sejam um palíndromo. Solução: dp com pré-processamento em O(n^2) que determina a matriz is_pal, tal que is_pal[i][j] = 1 se a substring s[i:j] é um palíndromo. Depois outra dp em O(n^2), com estado dp[i] representando o número mínimo de partes em que a substring s[1:i] pode ser dividida com todas as partes sendo palíndromos, com caso base dp[0] = 0 (string vazia) e equação de recorrência dp[i] = min_{j < i : is_pal[j+1][i]} dp[j] + 1, i = {1, ..., n}
PAO07		-							-
PAPEL09		-							-
PAPRIMAS	- MATEMÁTICA 				- determinar se o valor inteiro do hash de uma palavra é um número primo 
PAR			- TRIVIAL 					- imprimir o vencedor de um jogo de par ou ímpar
PARIDADE	- ADHOC 					- dado um unsigned int N, converter N para representação binária e contar número de bits iguais a 1 em N
PARPROX		- GEOMETRIA					- determinar a distância entre o par de pontos mais próximos no plano. Solução: como são no máximo 1000 pontos, o algoritmo O(n^2) passa. Implementei com line sweep em O(n log n)
PARQUE		- DP						- dadas duas strings s1 e s2, determinar qual a menor string s tal que s1 e s2 sejam subsequências de s. Solução: dp semelhante ao LCS
PARREIRA	- BUSCA BINÁRIA				- dada uma matriz de inteiros NxM em que os elementos das linhas e das colunas são ordenados em ordem não decrescente, responder várias queries para determinar o maior lado de uma sub-matriz quadrada tal que todos os elementos sejam maiores ou iguais a L e menores ou iguais a U. Solução: para cada linha, fazer uma busca binária (lower_bound da STL) para determinar qual o primeiro elemento maior ou igual a L. Depois fazer uma busca binária para descobrir o maior quadrado válido em que a célula mais em cima à esquerda é a célula dada pela função lower_bound. Para tanto, basta acessar a posição correspondente na diagonal e verificar se ela é menor ou igual a U. Complexidade: O(Q x (N log N)).
PAS11		-							-
PASSEIO		- GRAFOS 					- encontrar o tamanho do maior caminho em um DAG começando a partir de um vértice origem. Solução: dfs ou topsort + dp
PBOMBEIR	- GEOMETRIA					- dados 3 pontos no plano, determinar as coordenadas do ponto equidistante dos 3 pontos, ou dizer que existem 0 ou infinitos pontos equidistantes. Solução: se os 3 pontos não são colineares, basta encontrar o circuncentro do triângulo definido pelos 3 pontos, ou seja, o centro da circunferência circunscrita ao triângulo. Se os 3 pontos são colineares e todos distintos, não existe nenhum ponto equidistante dos 3. Se os 3 pontos são colineares mas pelo menos dois deles são iguais, então existem infinitos pontos equidistantes deles. Para determinar se os 3 pontos são colineares, basta calcula a área do triângulo formado por eles.
PEDAGIO		- GRAFOS 					- encontrar todos os vértices que estão a uma distância máxima do vértice origem. Solução: dfs
PEDAGIO1	- TRIVIAL					- O(1)
PENTA		- SIMULAÇÃO/GULOSO			- existe um conjunto com capacidade para K inteiros distintos e a demanda que no i-ésimo instante de tempo o inteiro v[i] esteja dentro do conjunto. Qual o número mínimo de trocas necessárias entre elementos de dentro com elementos de fora do conjunto para atender a demanda. Solução: simulação gulosa. A cada iteração, escolhe-se para retirar do conjunto aquele elemento que vai entrar mais no futuro no conjunto novamente.
PESCA11		-							-
PIZZA07		-							-
PLACAR 		- ADHOC 					- ordenação
PLAGIO		- STRING					- dada uma música M e um trecho de música T representados por suas notas, determinar se T é um trecho de M (mesmo que em outro tom). Solução: string matching simples com KMP
POLEPOS		- TRIVIAL 					- dadas as posições atuais de N carros em uma corrida, e as diferenças das posições atuais pras iniciais, determinar as posições iniciais ou concluir que é impossível que as informações de entrada estejam corretas.
POLIGONO	- MATEMÁTICA				- dados N pontos de um polígono inscrito em um círculo, determinar o menor número de pontos que devem ser removidos do polígono tal que o polígono resultante seja regular (todos os lados de mesmo tamanho). Solução: apesar de aparentemente ser um problema de geometria computacional, podemos analisá-lo em uma perspectiva de teoria dos números e divisibilidade. Primeiramente calculamos o tamanho C do círculo dado. Para que o polígono inscrito seja regular, é necessário que o ponto i esteja a uma mesma distância dos pontos i-1 e ponto i+1, para todo i, considerando a distância ao percorrermos o arco do círculo (segmento de sua circunferência) entre dois pontos. Portanto, basta calcularmos os divisores de C e para cada divisor d, verificar se é possível formar um polígono regular em que a distância do arco do círculo de um ponto a outro seja igual a d. Para tanto, calculamos a distância a_i de cada um dos N pontos do polígono original para um ponto 0 (referencial) da circunferência e calculamos o resto da divisão de cada a_i por d. O maior conjunto de pontos que resultaram em um mesmo resto da divisão de  a_i por d corresponde ao maior número de pontos que podemos manter do polígono original para formar um polígono regular em   que a distância do arco do círculo entre cada ponto seja igual a d. Se a quantidade de pontos for igual a C / d, encontramos uma solução viável pro problema, e basta compará-la com a melhor encontrada até o momento.
PONTES09	-							-
POPULAR 	- GRAFOS 					- determinar o maior grau de entrada do grafo dado pela matriz de adjacências
POSLIVRE	- ADHOC 					- dado um grid e vários retângulos cobrindo parte do grid, determinar qual a área livre. Como as dimensões são pequenas, o algoritmo simples passa tranquilo!
POWERGEN	- GRAFOS + GEOMETRIA		- dado um conjunto de pontos no plano, deve-se construir uma árvore geradora euclidiana entre esses pontos e particioná-la no maior número possível de subconjuntos tal que todos eles sejam conectados e a soma dos pesos dos vértices de cada subconjunto seja maior ou igual a um limite C. Solução: para criar a árvore geradora eucliana, pode-se usar o algoritmo O(n^2) de conectar o ponto i ao ponto mais próximo do conjunto de pontos {0, 1, ..., i-1}. Depois, basta fazer uma dfs na árvore incrementando a resposta toda vez que a sub-árvore enraizada no vértice explorado tiver peso maior ou igual a C. Se o peso for menor do que C, adiciona-se o peso total dessa sub-árvore no peso do vértice pai na dfs.
PRACAALI	- GULOSO					- dada uma lista de eventos de entrada e saída em um local, em que cada evento é descrito pelo horário (hora, minuto e segundo) e tipo (entrada, saída ou indefinido), atribuir a cada evento de tipo indefinido o tipo entrada ou saída de forma a maximizar o número de pessoas que estiveram presentes no loccal durante qualquer instante de tempo. Solução: ordenar eventos pelo horário, calcular o número de eventos indefinidos que são de entrada, e contar o número de pessoas presentes no momento atribuindo sempre o tipo entrada aos eventos de tipo indefinido se a quantidade de eventos do tipo entrada não tiverem ainda sido esgotadas. 
PREEMPOS	- ADHOC 					- dadas as listas de vértices de uma árvore binária em pre-order e in-order, imprimir a lista pos-order. Solução: Função recursiva que recebe as duas listas. Em cada recursão, o primeiro elemento da lista em pre-ordem é a raiz da árvore considerada naquela recursão. Basta então encontrar esse vértice na lista in-order, e tudo que está antes dele na lista in-order está na sub-árvore da esquerda e tudo o que está depois está na sub-árvore da direita. Basta então construir as novas duas listas pre-order e as duas in-order e chamar recursivamente.
PRIMO		- MATEMÁTICA 				- testar se um inteiro N, |N| < 2^31 é primo. Testei a implementação do Miller-Rabin.
PUSAPO11	-							-
QUADRAD2	- TRIVIAL 					- imprimir N^2
QUADRADO 	- STRING 					- string matching em uma matriz. transformar a matriz em uma representacao de long long e executar o KMP para cada uma das colunas (só passou no tempo após trabalhar na transposta da matriz)
QUASEMEN	- GRAFOS 					- 
QUERM 		- ADHOC						-
RECUPERA 	- ADHOC						-
REDOTICA	- GRAFOS 					- árvore geradora mínima
REGATA		- GRAFOS + GEOMETRIA 		- dados 2 pontos no plano, uma origem e em destino, e obstáculos formados por segmentos de reta, determinar o menor caminho entre o ponto origem e o ponto destino que não atravessa nenhum obstáculo. Montar o grafo em que cada ponto (origem, destino e os dois pontos extremos de cada obstáculo) corresponde a um vértice e cada caminho reto entre dois pontos que não se intersecta (exceto nas extremidades) com nenhum obstáculo é uma aresta. Rodar Djikstra!
REUNIAO2	- GRAFOS					- dado um grafo com arestas múltiplas e distâncias associadas às arestas, determinar a menor das distâncias máximas para ir de um vértice a outro qualquer, ou seja, determinar qual o vértice que está à menor distância possível do vértice mais longe. Solução: floyd warshall 
RMAPA11		-							-
ROBOCOL		- GRID						- caminhar com um robô em um grid seguindo orientação de alteração de sentido. Nada especial. 
RONTGEN		- ADHOC 					- imprimir a sequência clássica da entrevista do google em K iterações. Ex: 2, 12, 1112, 3112, 132112, 1113122112
ROTA		- GRAFOS 					- dado um grafo não direcionado com múltiplas arestas e um vértice destino, determinar quais as arestas que são críticas, ou seja, se removidas, fazem com que não haja nenhum caminho entre algum vértice e o vértice destino. Solução: Determinar as arestas da árvore de busca em profundidade a partir do vértice destino. Apenas essas arestas são candidatas para serem arestas críticas, uma vez que removendo-se qualquer outra aresta, ainda existiria pelo menos um caminho de qualquer vértice para o destino, sendo este o caminho existente na árvore de busca em profundidade. Para cada aresta da árvore de busca em profundidade, testar com uma dfs se a remoção dela desconecta algum vértice do vértice destino. Complexidade: O(nm). A solução simples O(m^2) de testar a remoção de todas as arestas também passa, se implementada com otimizações.
ROUBA		- SIMULAÇÃO					- simular um jogo simples de baralhos. Erro: esqueci de remover todas as cartas do monte de um jogador quando este monte era empilhado no monte de outro jogador
RUMO9S		- ADHOC 					- determinar a profundidade de uma função recursiva
SALDO 		- ADHOC 					- soma maxima de posicoes contínuas de um vetor, armazenando o início e o fim do intervalo
SANDUBA		- MATEMÁTICA/DP				- dado um vetor a de n posições, e definindo-se a linha i da matriz A como [a_i*a_1   a_i*a_2   ...   a_i*a_n], determinar a soma da matriz triangular superior de A, incluindo a diagonal principal. Solução: Como n pode chegar até 10^5, a solução trivial toma TLE. A soma dos elementos da matriz triangular superior da linha i pode ser reescrita como S_i = a_i * (a_i + a_{i+1} + ... + a_{n}). Portanto, podemos pré-calcular a soma parcial de cada linha de trás pra frente (soma[i] = a_i + a_{i+1} + ... + a_{n}, ou seja, soma[i] = soma[i+1] + a_i). Dessa forma, a resposta do problema é \sum_{i=1}^{n} a_i * soma[i]. 
SENHA		- ADHOC 					- determinar a senha em terminais eletrônicos bancários fazendo o mapeamento entre letras e algarismos
SELOS11		-							-
SEQUE		- RMQ + DP					- dada uma matriz retangular de inteiros, determinar a área da submatriz retangular crescente de maior área. Uma sub-matriz retangular que se lida linha a linha, da esquerda para a direita, de cima para baixo (row major order), resulta em uma sequência crescente de inteiros, é dita ser uma sub-matriz matriz retangular crescente. Podemos determinar para cada elemento (i,j) da matriz, quantos elementos consecutivos dele (inclusive) para a esquerda formam uma sequência estritamente decrescente, armazenando esses valores na matriz M. Para cada coluna j de M, basta agora pensar em um skyline em que o prédio i tem altura M[i][j] e utilizar um algoritmo para determinar a maior área consecutiva coberta pelos prédios da coluna j. Para resolver esse problema, podemos utilizar a estrutura de dados árvore de segmentos para responder RMQ em O(log n) e determinar a área máxima de forma recursiva. 
SEQUENCI 	- ADHOC						- 
SET			- FORÇA BRUTA				- dado um conjunto de N cartas, em que cada carta possui duas características (número {1,2,3} e figura {círculo,quadrado,triângulo}), e definindo-se um set como um conjunto de três cartas em que, para cada característica (número e figura), ou as três cartas são iguais, ou as três cartas são diferentes, deseja-se determinar qual o maior número de sets que podem ser formados. Existem 21 tipos de set, sendo 9 que usam três cartas exatamente iguais (tanto número quanto figura) e os 12 restantes. Suponha que a solução com maior número de sets formados use três ou mais sets iguais dentre esses 12 (ex: três sets compostos de: bbb qq t ou três sets de bbb bb b). Então podemos trocar três deles por sets compostos de cartas iguais (em vez de (bbb qq t) (bbb qq t) (bbb qq t) pode-se formar (bbb bbb bbb) (qq qq qq) (t t t) sem alterar o número total de sets). Então existe uma solução ótima que para cada um desses 12 tipos de sets, existem menos que tres dele. Assim para cada possibilidade (0, 1 ou 2 sets para cada) se testa, e com as cartas que sobrarem forma-se sets usando apenas cartas iguais. Assim são 3^12 possibilidades que podem ser testadas com um algoritmo força bruta.
SOMA		- TRIVIAL 					- imprimir a soma de N números
SORVETE		- ADHOC 					- dado o tamanho P de um segmento [1:P], e vários seguimentos pequenos [a:b], determinar os segmentos formados pela união desses segmentos.
SUBPRIME	- ADHOC						- dada uma lista de banco com a reserva monetária de cada um, e uma lista de dívidas entre os bancos, determinar se é possível pagar todas as dívidas utilizando apenas os resursos das reservas monetárias. solução: calcular o fluxo de caixa (saldo) de cada banco. se o fluxo de algum banco for negativo, a resposta é não. se o fluxo de todos os bancos forem não negativos, a resposta é sim.
SUDOIME 	- ADHOC 					- verificar se um tabuleiro é uma solucao valida para o sudoku
SUPERMER	- ADHOC						- dado um conjunto C de células marcadas em um grid, determinar qual a célula do grid que tem a menor distância pras células de C, em que a distância é definida como a soma das distâncias de manhattan. Por exemplo, se o conjunto é {1,5,7}, a distância do 3 pro conjunto é: 2+2+4 = 8. Solução: O problema é independente para cada coordenada, então o que queremos é achar o inteiro x que minimiza a distância pro conjunto X e o elemento y que minimiza a distância pro conjunto Y. É fácil ver que exite pelo menos um x em X que minimiza a distância, sendo esse x exatamente a mediana de X. Portanto, a resposta é a mediana de X e de Y, que pode ser encontrada com o nth-element.
TCELULA		- GEOMETRIA					- dado um conjunto de N pontos no plano, determinar qual o menor raio de duas circunferências que cubram todos os N pontos (os raios das duas circunferências devem ser iguais). Solução: para cada conjunto de 3 pontos distintos, determinar o minimum spanning circle C1 e determinar o minimum spanning circle C2 para todos os pontos que não estiverem cobertos por C1. O maior dos raios entre C1 e C2 deve ser considerado. Lembrar de tratar os casos especiais em que N = 3 e N = 4.
TELEMAR7	-							-
TELESCO2	- TRIVIAL					- determinar o número de casos na entrada em que o produto de dois valores é maior ou igual a uma constante
TENTA		- ADHOC						- imprimir todas as permutações de um vetor de tamanho no máximo 8. Basta usar a função next_permutation da STL
TEOBALDO	- GRAFOS					- determinar se existe um caminho do vértice s ao vértice t com exatamente d arestas (pode repetir vértices no caminho). Solução: itera sobre o número de arestas e em cada iteração constrói o vetor ok a partir do vetor ok da iteração anterior, em que ok[i] representa se o vértice i pode ser alcançado naquela iteração.
TESOUR11	-							-
TESOURO		- DP						- subset sum
TETRIS		- TRIVIAL 					- ordenação
TIMES1		- ORDENAÇÃO					- ordenar um conjunto de strings
TOMADA13	-							-
TRADUTO2	- DP						- dada uma string numérica, determinar o número de partições viáveis dessa string tal que cada componente seja formado por um inteiro entra 1 e N. Solução: dp com estado dp[i] = número de particoes viaveis do texto t[i,...,m-1], caso base dp[m-1] = 0 se t[m-1] = 0 e 1 c.c. e recorrência dp[i] = \sum_{i <= j < i+n} dp[j] (se t[i,...,j] <= s)
TRANSP11	-							-
TRIANG11	-							-
TRILHAS		- ADHOC						- o esforço de subida de um percurso é definido como o somatório dos esforços de subida dos trechos daquele percurso.
TROCCARD	- ADHOC						- dados dois conjuntos de inteiros A e B, calcular min( A\B, B\A ). Solução: direta com o uso de set
TUBOS		- GRAFOS					- dado um grafo não direcionado conectado, determinar se é possível escolher uma orientação para cada uma das arestas de forma que o grafo direcionado resultante seja fortemente conectado. Solução: determinar se existe aresta ponte no grafo. Se existir uma ponte, então a resposta para o problema é não. Caso contrário, a resposta é sim.
TV			- ADHOC 					- dada uma matriz MxN de inteiros e K deslocamentos nos eixos x e y a serem feitos em todos os elementos dessa matriz, imprimir a matriz resultante. Solução: O algoritmo O(KxMxN) dá TLE. Para resolver em O(K) + O(MxN), basta acumular os deslocamentos nos eixos x e y e fazer os deslocamentos apenas uma vez.
VARETAS		- TRIVIAL 					- determinar o número de retângulos que podem ser formados com um conjunto de varetas
VIVO		- SIMULAÇÃO					- simulação trivial
VIZINHOS	- GRAFOS					- trivial, saber qual vértice tem o maior grau de saída em um grafo direcionado
VOLEI		- GRAFOS/GEOMETRIA			- Dado um polígono de N vértices representando uma quadra, em que todas as arestas ou são paralelas ao eixo x ou ao eixo y, determinar o menor número de guardas que devem ser colocados tal que todas as arestas do polígono possam ser vistas por pelo menos um guarda, com a restrição de que um guarda deve sempre ficar fora da quadra. Solução: Utilizar dois vetores auxiliares, um X com as coordenadas x dos segmentos verticais e um Y com as coordenadas y dos segmentos horizontais. Para cada ponto (X[i],Y[j]) que está fora do polígono P, podemos substituir os 2 juízes originais que seriam necessários para guardar o segmento vertical i e o segmento horizontal j por apenas 1 juíz neste ponto. Cria-se então um grafo bipartido com partições X e Y e cria-se uma aresta com capacidade igual a 1 do vértice x[i] para o vértice y[i] se o ponto (x[i], y[i]) está fora da quadra. A resposta é tamanho(X)+tamanho(Y)-matching_máximo, com o matching máximo correspondendo ao fluxo máximo na rede associada com um source e um sink.
WCW			- ORDENAÇÃO 				- determinar o número mínimo de trocas para ordenar uma permutação dos elementos de 1 a N. Solução: detecção dos ciclos da permutação. O número mínimo de trocas necessárias para ordenar o vetor é igual N - #ciclos 
